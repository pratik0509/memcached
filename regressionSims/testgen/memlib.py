#!/usr/bin/python

################################################################################
#                                                                              #
#                     W E L C O M E    A D V E N T U R E R                     #
#                                                                              #
# This file shall be of great help to you on your jouney to become the leading #
# provider of server appliances in database applications. It will assist you   #
# on this task of providing a fully verified and thourghouly tested memcached  #
# server application bringing great honour to you and your kin of which is     #
# spoken even amongst the highest ranks that is our management.                #
#                                                                              #
# To get you started, you will find this file divided into several sections    #
# faciliating your learning thereof and thus empowering you with confidence to #
# start your battle.                                                           #
#                                                                              #
# The first section shows you how to define a key/value pair along with its    #
# parameters.  This is the foundation of your work with memcached.             #
#                                                                              #
# Section two provides functions to generate binary requests and corresponding #
# responses for the key/value pairs you learned about in the first section.    #
# They return an ASCII-encoded hexstream of the request or response.  This is  #
# the real stuff! You can send this either over the wire to a real server or   #
# feed it to your simulation.                                                  #
#                                                                              #
# Section three provides the same for the ASCII protocol.                      #
#                                                                              #
# Section four allows you to convert ASCII protcol requests into mixed         #
# protocol requests completing the memcached protocol familiy.                 #
#                                                                              #
# Section five provides all the means for you to generate RTL simulation input #
# files from the request streams generated by the above protocol-specific      #
# functions.  Given a list of request streams, it will combine them together   #
# such that they can be used with the kvs_tbDriver.vhdl used in the system to  #
# date. You will only want to use the last 3 functions in the section and      #
# neglect the previous helper functions.                                       #
#                                                                              #
# This is all you need to know my scholar to generate magnificent testbenches  #
# providing code stability boosting your stand as engineer and driving the     #
# markets with astonishing products. It was a pleasure teach you.              #
#                                                                              #
#                M A Y   Y O U   R E T U R N   I N   G L O R Y                 #
#                                                                              #
#                                                                              #
# Oh, you are still here? Well, then you must have noticed that there is a     #
# sixth section in this file. Well observed my friend. You are truely eager to #
# learn! Know then that this truly is the secret of rapid test crafting. It is #
# the wise man's approach, or, as I call it: the lazy man's toolbox. You just  #
# want to specify a series of request and don't care about protocol specifics? #
# This is for you! Just give the operations and the key/value pair and it will #
# automatically generate requests for all all possible combinations of         #
# protocols, rates and outputs, writes them all to files together with a       #
# summary. Need a particular setup? No worry, the file is there. All done for  #
# you.  There is nothing anymore that stands in your way now. This is really   #
# all I can teach you. Off you go now!                                         #
#                                                                              #
################################################################################



import sys

## kv_pair data structure ######################################################

# Example kv_pair: (key, value, flags, expiration)
ex_kv_pair = {
	"key"        : "ExampleKey",
	"value"      : "ExampleValue",
	"flags"      : "01234567",     # 32bit, hex-encoded
	"expiration" : 10
}

def kv_pair(key, value, flags, expiration):
	if (type(key) != str) | (type(value) != str) | (type(expiration) != int) | (type(flags) != str):
		raise Exception("Error: Wrong types for kv_pair")
	if len(flags) != 8:
		raise Exception("Error: Wrong flags length: %d. Should be 8." % len(flags))
	return {
		"key"        : key,
		"value"      : value,
		"flags"      : flags,
		"expiration" : expiration
	}

## binary protocol packet generators ###########################################

def binaryResponseTemplate(opcode, opaque, status="00"):
	magic             = "81"
	key_length_bin    = "0000"
	extras_length_bin = "00"
	data_type         = "00"
	status            = "00" + status
	body_length       = "00000000"
	cas               = "0000000000000000"

	response = magic + opcode + key_length_bin +        \
	           extras_length_bin + data_type + status + \
	           body_length +                            \
	           opaque +                                 \
	           cas

	return response

def binaryGetRequest(kv_pair, opaque="01234567"):
	if len(opaque) != 8:
		raise Exception("Error: Wrong opaque length: %d. Should be 8." % len(opaque))

	magic          = "80"
	opcode         = "00"
	key            = kv_pair["key"]
	key_bin        = key.encode('hex')
	key_length     = len(key)
	key_length_bin = "%04x" % key_length
	extras_length  = "00"
	data_type      = "00"
	vbucket_id     = "0000"
	body_length    = "%08x" % key_length
	cas            = "0000000000000000"

	request = magic + opcode + key_length_bin +        \
	          extras_length + data_type + vbucket_id + \
		  body_length +                            \
		  opaque +                                 \
		  cas +                                    \
		  key_bin

	return request

def binaryFailedGetResponse(opaque="01234567"):
	magic             = "81"
	opcode            = "00"
	key_length_bin    = "0000"
	extras_length_bin = "00"
	data_type         = "00"
	status            = "0001"
	body_length       = "00000008"
	cas               = "0000000000000000"
	message           = "ERROR 01".encode('hex')

	response = magic + opcode + key_length_bin +        \
	           extras_length_bin + data_type + status + \
	           body_length +                            \
	           opaque +                                 \
	           cas +                                    \
		   message

	return response

def binaryGetResponse(kv_pair, opaque="01234567"):
	if len(opaque) != 8:
		raise Exception("Error: Wrong opaque length: %d. Should be 8." % len(opaque))

	magic             = "81"
	opcode            = "00"
	key_length_bin    = "0000"
	extras            = kv_pair["flags"]
	extras_length     = len(extras) / 2
	extras_length_bin = "%02x" % extras_length
	data_type         = "00"
	status            = "0000"
	value             = kv_pair["value"]
	value_bin         = value.encode('hex')
	value_length      = len(value)
	body_length       = "%08x" % (extras_length + value_length)
	cas               = "0000000000000000"

	response = magic + opcode + key_length_bin +        \
	           extras_length_bin + data_type + status + \
	           body_length +                            \
	           opaque +                                 \
	           cas +                                    \
	           extras +                                 \
	           value_bin

	return response

def binarySetRequest(kv_pair, opaque="01234567"):
	if len(opaque) != 8:
		raise Exception("Error: Wrong opaque length: %d. Should be 8." % len(opaque))

	magic          = "80"
	opcode         = "01"
	key            = kv_pair["key"]
	key_bin        = key.encode('hex')
	key_length     = len(key)
	key_length_bin = "%04x" % key_length
	extras_length  = "08"
	data_type      = "00"
	vbucket_id     = "0000"
	value          = kv_pair["value"]
	value_bin      = value.encode('hex')
	value_length   = len(value)
	body_length    = "%08x" % (key_length + value_length + 8)
	cas            = "0000000000000000"
	flags          = kv_pair["flags"]
	expiration     = kv_pair["expiration"]
	expiration_bin = "%08x" % expiration
	extras         = flags + expiration_bin

	request = magic + opcode + key_length_bin +        \
	          extras_length + data_type + vbucket_id + \
		  body_length +                            \
		  opaque +                                 \
		  cas +                                    \
		  extras +                                 \
		  key_bin +                                \
		  value_bin

	return request

def binarySetResponse(kv_pair, opaque="01234567"):
	if len(opaque) != 8:
		raise Exception("Error: Wrong opaque length: %d. Should be 8." % len(opaque))
	return binaryResponseTemplate("01", opaque)

def binaryFailedSetResponse(opaque="01234567"):
	magic             = "81"
	opcode            = "01"
	key_length_bin    = "0000"
	extras_length_bin = "00"
	data_type         = "00"
	status            = "0001"
	body_length       = "00000008"
	cas               = "0000000000000000"
	message           = "ERROR 01".encode('hex')

	response = magic + opcode + key_length_bin +        \
	           extras_length_bin + data_type + status + \
	           body_length +                            \
	           opaque +                                 \
	           cas +                                    \
		   message

	return response

def binaryDeleteRequest(kv_pair, opaque="01234567"):
	if len(opaque) != 8:
		raise Exception("Error: Wrong opaque length: %d. Should be 8." % len(opaque))

	magic          = "80"
	opcode         = "04"
	key            = kv_pair["key"]
	key_bin        = key.encode('hex')
	key_length     = len(key)
	key_length_bin = "%04x" % key_length
	extras_length  = "00"
	data_type      = "00"
	vbucket_id     = "0000"
	body_length    = "%08x" % key_length
	cas            = "0000000000000000"

	request = magic + opcode + key_length_bin +        \
	          extras_length + data_type + vbucket_id + \
		  body_length +                            \
		  opaque +                                 \
		  cas +                                    \
		  key_bin

	return request

def binaryFailedDeleteResponse(kv_pair, opaque="01234567"):
	if len(opaque) != 8:
		raise Exception("Error: Wrong opaque length: %d. Should be 8." % len(opaque))

	magic             = "81"
	opcode            = "04"
	key_length_bin    = "0000"
	extras_length_bin = "00"
	data_type         = "00"
	status            = "0001"
	body_length       = "00000008"
	cas               = "0000000000000000"
	message           = "ERROR 01".encode('hex')

	response = magic + opcode + key_length_bin +        \
	           extras_length_bin + data_type + status + \
	           body_length +                            \
	           opaque +                                 \
	           cas +                                    \
		   message

	return response

def binaryDeleteResponse(kv_pair, opaque="01234567"):
	if len(opaque) != 8:
		raise Exception("Error: Wrong opaque length: %d. Should be 8." % len(opaque))
	return binaryResponseTemplate("04", opaque)

def binaryFlushRequest(expiration=0, opaque="01234567"):
	if len(opaque) != 8:
		raise Exception("Error: Wrong opaque length: %d. Should be 8." % len(opaque))

	if(expiration!=0):
		extras_length = "04"
		expiration_bin = "%08x" % expiration
		body_length   = "00000004"

	magic          = "80"
	opcode         = "08"
	key_length_bin = "0000"
	extras_length  = "00"
	data_type      = "00"
	vbucket_id     = "0000"
	body_length    = "00000000"
	cas            = "0000000000000000"
	expiration_bin = ""

	if(expiration!=0):
		extras_length  = "04"
		body_length    = "00000004"
		expiration_bin = "%08x" % expiration

	request = magic + opcode + key_length_bin +        \
	          extras_length + data_type + vbucket_id + \
		  body_length +                            \
		  opaque +                                 \
		  cas +                                    \
		  expiration_bin

	return request

def binaryFlushResponse(opaque="01234567"):
	if len(opaque) != 8:
		raise Exception("Error: Wrong opaque length: %d. Should be 8." % len(opaque))
	return binaryResponseTemplate("08", opaque)

## text protocol packet generators #############################################

def textSetRequest(kv_pair):
	txt_req = "set %s %d %d %d\r\n%s\r\n" % (
		kv_pair['key'],
		int(kv_pair['flags'], 16),
		kv_pair['expiration'],
		len(kv_pair['value']),
		kv_pair['value'])
	return txt_req.encode('hex')

def textSetResponse(kv_pair):
	return "STORED\r\n".encode('hex')

def textGetRequest(kv_pair):
	txt_req = "get %s\r\n" % kv_pair['key']
	return txt_req.encode('hex')

def textGetResponse(kv_pair):
	txt_res = "VALUE %s %d %d\r\n%s\r\nEND\r\n" % (
		kv_pair['key'],
		int(kv_pair['flags'], 16),
		len(kv_pair['value']),
		kv_pair['value'])
	return txt_res.encode('hex')

def textFailedGetResponse():
	return "END\r\n".encode('hex')

def textDeleteRequest(kv_pair):
	txt_req = "delete %s\r\n" % kv_pair['key']
	return txt_req.encode('hex')

def textDeleteResponse(kv_pair):
	return "DELETED\r\n".encode('hex')

def textFailedDeleteResponse(kv_pair):
	return "NOT_FOUND\r\n".encode('hex')

def textFlushRequest():
	return "flush_all\r\n".encode('hex')

def textFlushResponse():
	return "OK\r\n".encode('hex')

## mixed protocol converter (from text) ########################################

def goMixed(txt_rq, rq_id=0):
	frame = "%04x000000010000" % rq_id
	return (frame + txt_rq)

## simulation marshalling ######################################################

network_sop = "D001ADB002020203719A0E0002054" # why '4' and not '0' {EOP, MOD}?
network_any = "D001ADB002020203719A0E0002044"
network_eop = "D001ADB002020203719A0E000204C"
network_sep = "D001ADB002020203719A0E000205C"

network_out_x = "D001ADB002020203719A0E00020"
network_out_sop = network_out_x + "50"
network_out_any = network_out_x + "40"

network_out_x_hls = "D0000000000000000000000000000"
network_out_sop_hls = "D0001ADB002020203719A0E000210" # 
network_out_any_hls = network_out_x_hls + "00"

network_hls = "001ADB002020203719A0E000204" # Used for HLS packets. Only the network data are included. SOP & EOP signals are provided separately.
network_hls_any_short = "000000000000000000000000000"
network_hls_any = "D00000000000000000000000000000"

def split_string_into_len(str, size=8):
	return [ str[i:i+size] for i in range(0, len(str), size) ]

def hexstream_reverse_bytes(hexstream):
	bytes = split_string_into_len(hexstream, 2)
	reversed_bytes = bytes[::-1]
	return "".join(reversed_bytes)

# Empty: Control signals in the end set for 'empty' in simulation.
#        Use before W statement.
def simulationInput(hexstream, empty=True):
	lastDict = {0 : "FF", 1 : "01", 2 : "03", 3 : "07", 4 : "0F", 5 : "1F", 6 : "3F", 7 : "7F"}
	hexstream = hexstream.upper()
	residue = (len(hexstream) % 16) / 2
	if (residue != 8):
		keepSignal = lastDict[residue]
	else:
		keepSignal = "FF"
	
	while len(hexstream) % 16 != 0:
		hexstream = hexstream + "00"
		
	words = split_string_into_len(hexstream, 16)
	words = map(hexstream_reverse_bytes, words)

	if(len(words)==1):
		l2 =  "D" + words[0] + " " + keepSignal + ' 1' + "\n"
		input = l2
	elif(len(words)==2):
		l1 = "D" + words[0] + " " + "FF" + ' 0' + "\n"
		l2 = "D" + words[1] + " " + "FF" + ' 1' + "\n"
		input = l1 + l2
	else:
		words[0] = "D" + words[0] + " " + "FF" + ' 0' + "\n"
		words[1:-2] = map(lambda s: "D" + s + " FF 0" + "\n", words[1:-2])
		words[-2] = "D" + words[-2] + " " + 'FF 0' + "\n"
		words[-1] = "D" + words[-1] + " " + keepSignal + ' 1' + "\n"
		input = "".join(words)
	return input

def simulationOutput(hexstream):
	lastDict = {0 : "FF", 1 : "01", 2 : "03", 3 : "07", 4 : "0F", 5 : "1F", 6 : "3F", 7 : "7F"}
	if hexstream=="":
		return ""

	hexstream = hexstream.upper()
	residue = (len(hexstream) % 16) / 2
	if (residue != 8):
		keepSignal = lastDict[residue]
	else:
		keepSignal = "FF"

	while len(hexstream) % 16 != 0:
		hexstream = hexstream + "00"

	words = split_string_into_len(hexstream, 16)
	words = map(hexstream_reverse_bytes, words)

	if(len(words)==1):
		l2 =  "D" + words[0] + " " + keepSignal + ' 1' + " 2\n"
		input = l2
	elif(len(words)==2):
		l1 = "D" + words[0] + " FF 0" + "\n"
		l2 = "D" + words[1] + " " + keepSignal + ' 1' + " 2\n"
		input = l1 + l2
	else:
		words[0] = "D" + words[0] + " FF 0" + " 2\n"
		words[1:-2] = map(lambda s: "D" + s + " FF 0" + " 2\n", words[1:-2])
		words[-2] = "D" + words[-2] + " FF 0" + " 2\n"
		words[-1] = "D" + words[-1] + " " + keepSignal + ' 1' + " 2\n"
		input = "".join(words)
	return input

# expects list of hexstreams
def requests12Gbps(requests):
	requests = requests[:] # copy of list
	requests[0:-1] = map(lambda r: simulationInput(r, False), requests[0:-1])
	requests[-1] = simulationInput(requests[-1], True)
	return "".join(requests)

# expects list of hexstreams
def requests1Gbps(requests):
	input = map(lambda r: simulationInput(r, True), requests)
	pkg_count = map(lambda r: len(r) / 16, requests)
	pkg_wait_count = map(lambda c: 9*c, pkg_count)
	pkg_wait = map(lambda wc: "W%d\n" % wc, pkg_wait_count) # wait statement for each of the rqs.
	input_pairs = zip(pkg_wait, input)
	input_pairs = map(lambda p: "".join(p), input_pairs)    # wait and request combined for each rq
	return "".join(input_pairs)                             # 1 string w/ all rqs

# expects list of hexstreams
def responses(res):
	res = map(simulationOutput, res)
	return "".join(res)

###################### Functions which generate the data for the HLS data ###########################
def simulationInput_hls(hexstream, empty=True):

	#requestLength = len(hexstream)
	hexstream = hexstream.upper()
	while len(hexstream) % 16 != 0:
		hexstream = hexstream + "00"

	words = split_string_into_len(hexstream, 16)
	words = map(hexstream_reverse_bytes, words)

	if(len(words)==1):
		l2 =  network_hls + " " + words[0] + " " + '1' + " " + '1' + " " + '0' + " " + '1' + "\n"
		input = l2
	elif(len(words)==2):
		l1 = network_hls + " " + words[0] + " " + '1' + " " + '0' + " " + '0' + " " + '1' + "\n"
		l2 = network_hls + " " + words[1] + " " + '0' + " " + '1' + " " + '0' + " " + '1' + "\n"
		input = l1 + l2
	else:
		words[0] = network_hls + " " + words[0] + " " + '1' + " " + '0' + " " + '0'+ " " + '1' + "\n"
		words[1:-2] = map(lambda s: network_hls + " " + s + " " + '0' + " " + '0' + " " + '0'+ " " + '1' + "\n", words[1:-2]) 
		words[-2] = network_hls + " " + words[-2] + " " + '0' + " " + '0' + " " + '0' + " " + '1' + "\n"
		words[-1] = network_hls + " " + words[-1] + " " + '0' + " " + '1' + " " + '0' + " " + '1' + "\n"
		input = "".join(words)

	return input

def simulationOutput_hls(hexstream):
	if hexstream=="":
		return ""

	requestLength = len(hexstream) / 2
	#requestLength = requestLength << 1
	rlString = hex(requestLength)
	rlString = rlString[2:]
	if (len(rlString) < 5):
		for k in range (0, 3-len(rlString)):
			rlString = "0" + rlString
	#if (len(rlString) == 4):
	#	rlString = "0" + rlString[2:]
	#else:
	#	rlString = rlString[2:]
	hexstream = hexstream.upper()
	#print(rlString.upper())

	modulo = (len(hexstream) % 16) / 2
	mod_eop = "%x" % (modulo + 8) # 8 = EOP
	mod_eop = mod_eop.upper()

	while len(hexstream) % 16 != 0:
		hexstream = hexstream + "**"

	words = split_string_into_len(hexstream, 16)
	words = map(hexstream_reverse_bytes, words)

	if(len(words)==1):
		words[0] = rlString.upper() + network_hls[3:] + " " + words[0] + " " + '1' + " " + '1' + " " + str(modulo) + " " + '1' + "\n"
		#words[0] = network_hls[0:2] + rlString.upper() + network_hls[3:] + " " + words[0] + " " + '1' + " " + '1' + " " + str(modulo) + " " + '1' + "\n"
		#words[0] = network_hls[0:3] + "\n"
		#words[0] = rlString.upper() + "\n"
	else:
		#words[0] = network_hls[0:0] + rlString.upper() + network_hls[3:] + " " + words[0] + " " + '1' + " " + '0' + " " + '0'+ " " + '1' + "\n"
		words[0] = rlString.upper() + network_hls[3:] + " " + words[0] + " " + '1' + " " + '0' + " " + '0'+ " " + '1' + "\n"
		words[1:-1] = map(lambda s: network_hls_any_short + " " + s + " " + '0' + " " + '0' + " " + '0'+ " " + '1' + "\n", words[1:-1])
		words[-1] = network_hls_any_short + " " + words[-1] + " " + '0' + " " + '1' + " " + str(modulo) + " " + '1' + "\n"

	return "".join(words)

def simulationOutput_rtl_hls(hexstream):
	if hexstream=="":
		return ""

	requestLength = len(hexstream) / 2
	requestLength = requestLength << 1
	rlString = hex(requestLength)
	if (len(rlString) == 4):
		rlString = "0" + rlString[2:]
	else:
		rlString = rlString[2:]
	hexstream = hexstream.upper()

	modulo = (len(hexstream) % 16) / 2
	mod_eop = "%x" % (modulo + 8) # 8 = EOP
	mod_eop = mod_eop.upper()

	while len(hexstream) % 16 != 0:
		hexstream = hexstream + "**"

	words = split_string_into_len(hexstream, 16)
	words = map(hexstream_reverse_bytes, words)

	if(len(words)==1):
		words[0] = network_out_x[0:3] + rlString.upper() + network_out_x[4:] + "5" + mod_eop + words[0] + " 2\n"
	else:
		words[0] = network_out_sop_hls[0:3] + rlString.upper() + network_out_sop_hls[4:] + words[0] + " 2\n"
		words[1:-1] = map(lambda s: network_out_any_hls + s + " 2\n", words[1:-1])
		words[-1] = network_out_x_hls + "0" + mod_eop + words[-1] + " 2\n"

	return "".join(words)

# expects list of hexstreams
def requests12Gbps_hls(requests):
	requests = requests[:] # copy of list
	requests[0:-1] = map(lambda r: simulationInput_hls(r, False), requests[0:-1])
	requests[-1] = simulationInput_hls(requests[-1], True)
	return "".join(requests)

# expects list of hexstreams
def requests1Gbps_hls(requests):
	input = map(lambda r: simulationInput_hls(r, True), requests)
	pkg_count = map(lambda r: len(r) / 16, requests)
	pkg_wait_count = map(lambda c: 9*c, pkg_count)
	pkg_wait = map(lambda wc: "W %d\n" % wc, pkg_wait_count) # wait statement for each of the rqs.
	input_pairs = zip(pkg_wait, input)
	input_pairs = map(lambda p: "".join(p), input_pairs)    # wait and request combined for each rq
	return "".join(input_pairs)                             # 1 string w/ all rqs

# expects list of hexstreams
def responses_hls(res):
	res = map(simulationOutput_hls, res)
	return "".join(res)

# expects list of hexstreams
def responses_rtl_hls(res):
	res = map(simulationOutput_rtl_hls, res)
	return "".join(res)

########################################################################################################

## Helpers for quick testcase scenario setup ###################################

# These functions allow you to specify a series of requests without specifying
# any protocol details. In the end, they produce
#
#   * the specified requests using the BINARY protocol
#   * the specified requests using the ASCII protocol
#   * at both, back-to-back and 1Gbps input rate
#   * the corresponding golden resoponse for automatic verification

def newTestset():
	return {
		'list'   : [],
		'bin_rq' : [],
		'bin_rs' : [],
		'txt_rq' : [],
		'txt_rs' : []
	}

def setSuccess(pair, set):
	set['list'].append("set [%d -> %d; %s]: %s -> %s" % (
		len(pair['key']),
		len(pair['value']),
		pair['flags'],
		pair['key'],
		pair['value'] ))

	set['bin_rq'].append( binarySetRequest(pair) )
	set['bin_rs'].append( binarySetResponse(pair) )
	set['txt_rq'].append( textSetRequest(pair) )
	set['txt_rs'].append( textSetResponse(pair) )

def setFail(pair, set):
	set['list'].append("set [%d -> %d; %s]: %s -> %s" % (
		len(pair['key']),
		len(pair['value']),
		pair['flags'],
		pair['key'],
		pair['value'] ))

	set['bin_rq'].append( binarySetRequest(pair) )
	set['bin_rs'].append( binaryFailedSetResponse(pair) )
	set['txt_rq'].append( textSetRequest(pair) )
	set['txt_rs'].append( textFailedSetResponse(pair) )		# Not supported at this stage

def getSuccess(pair, set):
	set['list'].append("getSuccess [%d -> %d; %s]: %s -> %s" % (
		len(pair['key']),
		len(pair['value']),
		pair['flags'],
		pair['key'],
		pair['value'] ))

	set['bin_rq'].append( binaryGetRequest(pair) )
	set['bin_rs'].append( binaryGetResponse(pair) )
	set['txt_rq'].append( textGetRequest(pair) )
	set['txt_rs'].append( textGetResponse(pair) )

def getFail(pair, set):
	set['list'].append("getFail [%d -> %d; %s]: %s -> %s" % (
		len(pair['key']),
		len(pair['value']),
		pair['flags'],
		pair['key'],
		pair['value'] ))

	set['bin_rq'].append( binaryGetRequest(pair) )
	set['bin_rs'].append( binaryFailedGetResponse() )
	set['txt_rq'].append( textGetRequest(pair) )
	set['txt_rs'].append( textFailedGetResponse() )

def delete(pair, set):
	set['list'].append("delete [%d -> %d; %s]: %s -> %s" % (
		len(pair['key']),
		len(pair['value']),
		pair['flags'],
		pair['key'],
		pair['value'] ))

	set['bin_rq'].append( binaryDeleteRequest(pair) )
	set['bin_rs'].append( binaryDeleteResponse(pair) )
	set['txt_rq'].append( textDeleteRequest(pair) )
	set['txt_rs'].append( textDeleteResponse(pair) )

def deleteFail(pair, set):
	set['list'].append("deleteFail [%d -> %d; %s]: %s -> %s" % (
		len(pair['key']),
		len(pair['value']),
		pair['flags'],
		pair['key'],
		pair['value'] ))

	set['bin_rq'].append( binaryDeleteRequest(pair) )
	set['bin_rs'].append( binaryFailedDeleteResponse(pair) )
	set['txt_rq'].append( textDeleteRequest(pair) )
	set['txt_rs'].append( textFailedDeleteResponse(pair) )

def flush(set):
	set['list'].append("flush")

	set['bin_rq'].append( binaryFlushRequest() )
	set['bin_rs'].append( binaryFlushResponse() )
	set['txt_rq'].append( textFlushRequest() )
	set['txt_rs'].append( textFlushResponse() )

def generate(name, set):
	f = open("%s_list.txt" % name, "w")
	for line in set['list']:
		print>>f, line
	f.close()

	f = open("%s_TXT_R12-pkt.in.txt" % name, "w")
	f.write( requests12Gbps(set['txt_rq']) )
	f.close()

	f = open("%s_TXT_R01-pkt.in.txt" % name, "w")
	f.write( requests1Gbps(set['txt_rq']) )
	f.close()

	f = open("%s_TXT-pkt.out.txt" % name, "w")
	f.write( responses(set['txt_rs']) )
	f.close()

	f = open("%s_TXT-pkt.out.hls.rtl.txt" % name, "w")	# This line creates the output files for the RTL simulation of the HLS modules. There are subtle differences there.
	f.write( responses_rtl_hls(set['txt_rs']) )
	f.close()

	f = open("%s_BIN_R12-pkt.in.txt" % name, "w")
	f.write( requests12Gbps(set['bin_rq']) )
	f.close()

	f = open("%s_BIN_R01-pkt.in.txt" % name, "w")
	f.write( requests1Gbps(set['bin_rq']) )
	f.close()

	f = open("%s_BIN-pkt.out.txt" % name, "w")
	f.write( responses(set['bin_rs']) )
	f.close()

	f = open("%s_BIN-pkt.out.hls.rtl.txt" % name, "w")	# This line creates the output files for the RTL simulation of the HLS modules. There are subtle differences there.
	f.write( responses_rtl_hls(set['bin_rs']) )
	f.close()

def generate_hls(name, set):
	f = open("%s_list.txt" % name, "w")
	for line in set['list']:
		print>>f, line
	f.close()

	f = open("%s_TXT_R12-pkt.in.hls.txt" % name, "w")
	f.write( requests12Gbps_hls(set['txt_rq']) )
	f.close()

	f = open("%s_TXT_R01-pkt.in.hls.txt" % name, "w")
	f.write( requests1Gbps_hls(set['txt_rq']) )
	f.close()

	f = open("%s_TXT-pkt.out.hls.txt" % name, "w")
	f.write( responses_hls(set['txt_rs']) )
	f.close()

	f = open("%s_TXT-pkt.out.hls.rtl.txt" % name, "w")
	f.write( responses_rtl_hls(set['txt_rs']) )
	f.close()

	f = open("%s_BIN_R12-pkt.in.hls.txt" % name, "w")
	f.write( requests12Gbps_hls(set['bin_rq']) )
	f.close()

	f = open("%s_BIN_R01-pkt.in.hls.txt" % name, "w")
	f.write( requests1Gbps_hls(set['bin_rq']) )
	f.close()

	f = open("%s_BIN-pkt.out.hls.txt" % name, "w")
	f.write( responses_hls(set['bin_rs']) )
	f.close()

	f = open("%s_BIN-pkt.out.hls.rtl.txt" % name, "w")
	f.write( responses_rtl_hls(set['bin_rs']) )
	f.close()

